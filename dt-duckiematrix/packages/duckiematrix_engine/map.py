"""Map."""

import logging
import subprocess
from pathlib import Path
from types import SimpleNamespace
from typing import IO, Any

import yaml

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


class MapAsset:
    """Duckiematrix Engine map asset."""

    _fpath: str

    def __init__(self, fpath: str) -> None:
        """Initialize Duckiematrix Engine map asset."""
        self._fpath = fpath

    def exists(self) -> bool:
        """Return `True` if the file exists, `False` otherwise."""
        path = Path(self._fpath)
        return path.is_file()

    @property
    def fpath(self) -> str:
        """Return the file path."""
        return self._fpath

    def make_dirs(self) -> None:
        """Make directories."""
        path = Path(self._fpath)
        path.parent.mkdir(parents=True, exist_ok=True)

    def open(self, mode: str) -> IO[Any]:
        """Open."""
        self.make_dirs()
        path = Path(self._fpath)
        return path.open(mode)

    def read(self, mode: str) -> str:
        """Read."""
        path = Path(self._fpath)
        with path.open(mode) as fin:
            return fin.read()

    def write(self, mode: str, data: str) -> int:
        """Write."""
        self.make_dirs()
        path = Path(self._fpath)
        with path.open(mode) as fout:
            return fout.write(data)


class MapLayer(dict):
    """Duckiematrix Engine map layer."""

    _version: str

    def __getitem__(self, key: str) -> dict:
        """Get Duckiematrix Engine map layer item."""
        try:
            return super().__getitem__(key)
        except KeyError:
            dictionary: dict = {}
            self[key] = dictionary
            return dictionary

    def __init__(
        self,
        version: str,
        *args: str,
    ) -> None:
        """Initialize Duckiematrix Engine map layer."""
        self._version = version
        super().__init__(*args)

    def as_raw_dict(self) -> dict[Any, dict]:
        """Return as a raw dictionary."""
        return dict(self)

    @property
    def version(self) -> str:
        """Return version."""
        return self._version

    @version.setter
    def version(self, version: str) -> None:
        self._version = version


class Map:
    """Duckiematrix Engine map."""

    SUPPORTED_LAYERS = (
        # generic (mostly passthrough)
        ("frames", True),
        ("tile_maps", True),
        ("tiles", False),
        ("traffic_signs", False),
        ("vehicles", False),
        ("watchtowers", False),
        ("traffic_lights", False),
        ("citizens", False),
        ("cameras", False),
        ("time_of_flights", False),
        ("imus", False),
        ("vehicle_dynamics", False),
        ("ground_tags", False),
        ("vehicle_tags", False),
        ("decorations", False),
        ("lights", False),
        ("wheels", False),
        ("frozen_frames", False),
        ("billboards", False),
        ("street_lights", False),
        ("laboratories", False),
        ("terrain", False),
        ("scripts", False),
        ("cameramen", False),
        # viewer
        ("markers", False),
        # generated by controller, used by renderers
        ("physical_cameras", False),
        ("renderer_assignments", False),
        ("renderer_mode", False),
        ("rendering_configuration", False),
        ("engine_configuration", False),
        # controller only
        ("physical_robots", False),
        # renderers only
        ("sensor_gates", False),
        ("renderer_authentication", False),
    )

    _assets_dir: str
    _layers: SimpleNamespace
    _path: str
    context_fpath: str | None
    name: str

    def __getattr__(self, layer: str) -> MapLayer:
        """Return Duckiematrix Engine map attribute."""
        if layer in self.layers:
            return self.layers[layer]
        message = f"Map has no layer '{layer}'"
        raise KeyError(message)

    def __getitem__(self, layer: str) -> MapLayer:
        """Return Duckiematrix Engine map item."""
        return self.__getattr__(layer)

    def __init__(self, name: str, path: str) -> None:
        """Initialize Duckiematrix Engine map."""
        self.name = name
        self._path = path
        assets_path = Path(self._path) / "assets"
        self._assets_dir = assets_path.as_posix()
        self._layers = SimpleNamespace()
        self.context_fpath = None

    def asset(self, key: str, name: str) -> MapAsset:
        """Return asset."""
        path = Path(self._assets_dir) / key / name
        asset_fpath = path.as_posix()
        return MapAsset(asset_fpath)

    @property
    def assets_dir(self) -> str:
        """Return assets directory."""
        return self._assets_dir

    @classmethod
    def from_disk(cls, name: str, maps_dir: str) -> "Map":
        """Return map from disk."""
        path = Path(maps_dir) / name
        map_dir = path.as_posix()
        map_ = Map(name, map_dir)
        # make sure the map exists on disk
        path = Path(map_dir)
        if not path.is_dir():
            message = f"The path '{map_dir}' is not a directory."
            raise NotADirectoryError(message)
        # load layers
        for layer, required in cls.SUPPORTED_LAYERS:
            layer_data = MapLayer("0.0.0")
            path = Path(map_dir) / f"{layer}.yaml"
            fpath = path.as_posix()
            if path.is_file():
                with path.open() as fin:
                    layer_raw: dict[str, str] = yaml.safe_load(fin)
                    try:
                        layer_content = layer_raw[layer]
                    except KeyError as error:
                        message = (
                            f"The layer file '{fpath}' does not have "
                            f"'{layer}' as key to the root object."
                        )
                        raise RuntimeError(message) from error
                    try:
                        version = layer_raw["version"]
                    except KeyError:
                        logger.warning(
                            "The layer file '%s' does not contain a 'version' "
                            "field. All layers should be versioned. Assuming "
                            "'0.0.0'.",
                            fpath,
                        )
                        version = "0.0.0"
                    layer_data = MapLayer(version, layer_content)
            elif required:
                message = (
                    f"The (required) layer file '{fpath}' does not exist."
                )
                raise FileNotFoundError(message)
            map_.layers[layer] = layer_data
        return map_

    @property
    def layers(self) -> dict:
        """Return layers."""
        return self._layers.__dict__

    def make_context(self) -> str:
        """Return context file path."""
        path = Path(self._path) / "context.zip"
        self.context_fpath = path.as_posix()
        if path.is_file():
            return self.context_fpath
        arguments = (
            "zip",
            "-b",
            "/tmp",
            "-x",
            "renderer_authentication.*",
            "-r",
            self.context_fpath,
            ".",
        )
        subprocess.check_output(arguments, cwd=self._path)
        return self.context_fpath

    def to_disk(self) -> None:
        """Write to disk."""
        # dump layers
        for layer, _ in self.SUPPORTED_LAYERS:
            layer_data = self.layers[layer]
            path = Path(self._path) / f"{layer}.yaml"
            with path.open("w") as fout:
                # we are not including the version as it is not easily
                # parseable by the renderers
                yaml.safe_dump(
                    {
                        layer: layer_data.as_raw_dict(),
                    },
                    fout,
                )
